using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using ValueOf.Extensions.ParsableGenerator;

namespace ValueOf.Extensions.Tests;

public class SourceGeneratorParsableValueOfTests
{
    private const string TestUserIdClassText = @"
namespace TestNamespace;
using ValueOf;

public sealed partial class TestUserId : ValueOf<int, TestUserId>
{
    protected override void Validate()
    {
        var userId = Value;
        if (userId <= 0)
            throw new ArgumentOutOfRangeException(nameof(userId) + $"" must be positive integer but is: {userId}"");
    }
}
";

    private const string ExpectedGeneratedClassText = @"
// <auto-generated/>
#nullable enable
using System;
using System.ComponentModel;
using System.Diagnostics.CodeAnalysis;
using System.Collections.Generic;

namespace TestNamespace;

public partial class TestUserId: IParsable<TestNamespace.TestUserId>
{
    private static readonly TypeConverter _converter = TypeDescriptor.GetConverter(typeof(TestNamespace.TestUserId));
    public static TestNamespace.TestUserId Parse(string s, IFormatProvider? provider)
    {
        return (TestNamespace.TestUserId)_converter.ConvertFrom(s)!;
    }

    public static bool TryParse([NotNullWhen(true)] string? s, IFormatProvider? provider, [MaybeNullWhen(false)] out TestNamespace.TestUserId result)
    {
        result = default(TestNamespace.TestUserId);
        if (_converter.CanConvertFrom(typeof(string)))
        {
            result = (TestNamespace.TestUserId)_converter.ConvertFrom(s)!;
            return true;
        }
        return false;
    }
}
";

    [Fact]
    public void GenerateIParsableMethods()
    {
        var generator = new SourceGeneratorParsableValueOf();

        var driver = CSharpGeneratorDriver.Create(generator);

        var compilation = CSharpCompilation.Create(nameof(SourceGeneratorParsableValueOf),
            new[] { CSharpSyntaxTree.ParseText(TestUserIdClassText) },
            new[]
            {
                MetadataReference.CreateFromFile(typeof(object).Assembly.Location),
                MetadataReference.CreateFromFile(typeof(ValueOf<,>).Assembly.Location)
            });

        var runResult = driver.RunGenerators(compilation).GetRunResult();

        var generatedFileSyntax = runResult.GeneratedTrees.Single(t => t.FilePath.EndsWith("TestUserId.g.cs"));

        Assert.Equal(ExpectedGeneratedClassText.Trim(), generatedFileSyntax.GetText().ToString().Trim(),
            ignoreLineEndingDifferences: true);
    }
}